% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Processi e metodologie}
\label{cap:processi-metodologie}
%**************************************************************

In questo capitolo verrà fornito una descrizione dei metodi e dei processi messi in atto durante il tirocinio, in particolare riguardo i seguenti argomenti: metodologia agile, programmazione funzionale e il concetto di Dataflow dell'applicazione.

%**************************************************************
\section{Metodologia Agile}
Per lo sviluppo del prodotto è stato deciso di utilizzare una metodologia agile in modo da reagire velocemente a problemi e a cambiamenti così da migliorare ed l'efficienza nella realizzazione della componente. L'azienda ha deciso di utilizzare una metodologia agile simile a SCRUM. Infatti applicare nella sua interezza il metodo SCRUM sarebbe stato impossibile dato il ristretto numero di sviluppatori nel team di sviluppo. \\
Le caratteristiche principali della metodologia agile applicata per la realizzazione di questo progetto sono le seguenti:
\begin{itemize}
	\item \textbf{Modello incrementale}: vengono realizzati rilasci multipli e successivi che aiutano a definire più chiaramente i requisiti più importanti dato che essi verranno implementati per primi. Ogni rilascio corrisponde ad una parte funzionante di applicazione;
	
	\item \textbf{Modello iterativo}: un modello iterativo ha la caratteristica di avere una maggior capacità di adattamento in seguito a problemi di implementazione e cambiamenti nei requisiti da parte del cliente;
	
	\item \textbf{Organizzazione in sprint di sviluppo}: il processo[controlla se è il termine giusto] di codifica viene suddiviso in sprint di sviluppo, data la breve durata del tirocinio curriculare essi avranno una durata di circa 4-5 giorni;
	
	\item \textbf{Backlog}: 
		\begin{itemize}
			\item \textbf{Product Backlog}: rappresenta i requisiti e le funzionalità del prodotto definiti mediante le User Stories;
			\item \textbf{Sprint Backlog}: rappresenta l'insieme delle User Stories da realizzare nello sprint indicato;
		\end{itemize}
	
	\item \textbf{User Stories}: l'idea alla base di uno sviluppo agile è la realizzazione delle User Stories. Ogni user story è definita da una \textbf{descrizione del problema} e da una \textbf{priorità}.
	
	\item \textbf{Riunioni}:
		\begin{itemize}
			\item \textbf{Sprint planning}: per pianificare il lavoro da svolgere durante lo sprint;
			\item \textbf{Sprint review}: riunione retrospettiva per verificare il lavoro svolto durante lo sprint;
			\item \textbf{Backlog refinement}: per aggiungere nuove User Stories o migliorare e/o modificare User Stories già create;
			\item \textbf{Riunioni giornaliere}: per verificare lo svolgimento del lavoro, in questo tirocinio sono state sostituite con comunicazioni telematiche giornaliere.
		\end{itemize}
\end{itemize}
% scrivere descrizione più accurata della metodologie agili applicate
\subsection{Definizione delle User Stories}
Per prima cosa il team di sviluppo si è occupato di realizzare le User Stories. Per definire un singolo elemento è stata utilizzata la seguente struttura:
\begin{longtable} {
		|>{}p{10mm}| 
		|>{}p{70mm}|
		|>{}p{15mm}|
		|>{}p{25mm}|
		>{}p{0mm}}
	\hline
	\textbf{Id} & \textbf{Descrizione} & \textbf{Priorità} & \textbf{Implementato} \\ \hline
	US1.1 & Descrizione dell'user story & A & SI \\ \hline
	\hline
	\caption{Esempio tabella User Story}
\end{longtable}
\noindent
Per ogni descrizione di un user story si possono identificare le seguenti informazioni:
\begin{itemize}
	\item \textbf{Ruolo}: definisce il tipo di utente;
	\item \textbf{Obiettivo}: definisce di che cosa ha bisogno l'utente;
	\item \textbf{Beneficio}: definisce i vantaggi che porta all'utente.
\end{itemize} 
\noindent
La sinteticità e la facilità nel definire le user story porta a vantaggi nella comunicazione tra il team di sviluppo e il cliente, rende più semplice l'aggiornamento dei requisiti e i costi di scrittura e manutenzione delle user stories sono molto bassi.

\subsection{Definizione del Product Backlog}
Uno dei primi obiettivi del progetto posti dal team di sviluppo è stato quello di definire il Product Backlog, cioè i requisiti del prodotto. Per ognuna delle user story precedentemente scritta è stata assegnata una priorità seguendo la seguente legenda:
\begin{longtable} {
		|>{\centering}p{10mm}| 
		|>{}p{25mm}|
		|>{}p{85mm}|
		>{}p{0mm}}
	\hline
	\textbf{A} & \textit{Priorità alta}  & funzionalità necessarie per il corretto funzionamento dell'applicazione \\ \hline
	\textbf{M} & \textit{Priorità media} & funzionalità che migliorano il prodotto \\ \hline
	\textbf{B} & \textit{Priorità bassa} & funzionalità non necessarie per il corretto funzionamento dell'applicazione \\ \hline
	\hline
	\caption{Tabella priorità User Story}
\end{longtable}
\noindent
Questo ci ha permesso di categorizzare le funzionalità principali del componente d'interfaccia grafico da quelle opzionali. Abbiamo quindi popolato il Product Backlog per ordine di \textit{priorità}, in questo modo la suddivisione delle user story per sprint, mediante le riunioni di \textit{Sprint Planning}, è stata chiara e veloce. \\
Infatti abbiamo concentrato le funzionalità principali da implementare nei primi due sprint così da avere già a partire dal terzo sprint una prodotto con le funzionalità principali già implementate.

\section{Programmazione funzionale}
La programmazione funzionale è un paradigma di programmazione dichiarativa dove un programma è costituito dall'applicazione e dalla composizione di funzioni. In questo progetto si è utilizzata, dove possibile, la programmazione funzionale in particolare mediante le \emph{Funzioni di ordine superiore} fornite da Kotlin. Queste funzioni sono molto utili perchè permettono di scrivere codice più leggibile, conciso e soprattutto hanno la caratteristica di evitare \emph{side-effects}. Come definito dalla documentazione di Kotlin (bib: https://kotlinlang.org/docs/reference/lambdas.html), le funzioni scritte nel linguaggio Kotlin sono considerate come \emph{first-class} quindi esse possono essere contenute in variabili e strutture dati, possono essere passate come argomento di altre funzioni e possono essere ritornate da altre \emph{Funzioni di ordine superiore}. Queste funzioni sono state usate estensivamente nella realizzazione del "parser" descritto nel capitolo 4:descrizione-stage.

\section{Dataflow dell'applicazione}
Un concetto che è stato discusso molto dal team di sviluppo riguardava il \emph{dataflow} dell'applicazione. Durante la prima settimana del tirocinio è stato discusso come verrà gestito lo stato dell'applicazione e in particolare delle soluzioni per rendere il componente scalabile. Per gestire lo stato dell'applicazione sono state individuate due possibili soluzioni: React e Redux.

\subsection{React}
React è una libreria per realizzare interfacce utente che utilizza un dataflow unidirezionale. Questo perchè ogni componente può avere uno stato locale accessibile solo dal componente stesso e può passare informazioni ai suoi componenti figli mediante le \emph{props}. \\
Questo dataflow è molto semplice però presenta alcune limitazioni per quanto riguarda la scalabilità. Per avere uno stato unico di tutta l'applicazione bisognerebbe dare la responsabilità ad un componente grafico di gestirlo e passarlo mediante le sue \emph{props}. L'architettura che deriva da questo dataflow, nel caso di applicazioni complesse con molti componenti, è limitata, difficile da manutenere e poco scalabile. \\
Tuttavia questo semplice dataflow ha il vantaggio che per famiglie di componenti piccole i cambiamenti di stato locale e i passaggi di informazioni mediante le \emph{props} sono molto veloci e semplici.

\subsection{Redux}
Per garantire garantire scalabilità e facilità di gestione dello stato dell'applicazione abbiamo discusso riguardo l'utilizzo di Redux. Come React essa offre un dataflow unidirezionale tuttavia lo stato non è più contenuto all'interno di una gerarchia di componenti grafici, bensì esso viene contenuto in una struttura chiamata \emph{store}. Questa struttura esterna ai componenti grafici rende la gestione dello stato dell'applicazione più prevedibile e più manutenibile. Redux si basa su tre principi:
\begin{itemize}
	\item lo stato è l'unica fonte di verità;
	\item lo stato non è modificabile direttamente;
	\item le modifiche avvengono medianti funzioni pure (glossario) che creano un nuovo stato per evitare side effects.
\end{itemize}
\noindent
Gli elementi dell'architettura di Redux sono i seguenti:
\begin{itemize}
	\item \textbf{Actions}: oggetti che rappresentano un azione che innesca un update dello stato;
	\item \textbf{Reducers}: \emph{funzioni pure} che hanno come parametro un Actions e si occupano di modificare lo stato;
	\item \textbf{Store}: lo Store è un'interfaccia che contiene lo stato dell'applicazione e fornisce funzioni per leggere, modificare e registrare listeners allo stato.
\end{itemize}
\noindent

\subsection{Soluzione}
La soluzione adottata è stata quella di usare sia React che Redux. React è stato usato per gestire solo gli aggiornamenti visivi dell'applicazione, mentre Redux per gestire lo stato dell'applicazione. Il dataflow del prodotto è quindi il seguente:
\begin{enumerate}
	\item se lo stato deve cambiare verrà mandata allo Store una richiesta di cambiamento con un Action;
	\item lo Store si occuperà di chiamare un Reducer in modo da modificare lo stato;
	\item lo stato verrà aggiornato e i cambiamenti saranno visibili a tutti i componenti React che sono registrati allo Store.
\end{enumerate}
