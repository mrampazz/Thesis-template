% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Processi e metodologie}
\label{cap:processi-metodologie}
%**************************************************************

In questo capitolo verrà fornita una descrizione dei metodi e dei processi messi in atto durante il tirocinio e in particolare riguardo: la metodologia agile, la programmazione funzionale, la gestione del progetto in locale e l'organizzazione del lavoro.

%**************************************************************
\section{Metodologia Agile}
Per lo sviluppo del prodotto è stato deciso di applicare una metodologia agile in modo da reagire velocemente a possibili problemi e cambiamenti dei requisiti così da migliorare e velocizzare la realizzazione dell'applicativo. L'azienda ha deciso di utilizzare una metodologia agile simile a \gls{scrumg}. Infatti applicarlo nella sua interezza sarebbe stato impossibile dato il ristretto numero di sviluppatori nel team di sviluppo e il limitato periodo riservato alla codifica. \\
Le caratteristiche principali della metodologia agile applicata per la realizzazione di questo progetto sono le seguenti:
\begin{itemize}
	\item \textbf{Modello incrementale}: vengono realizzati rilasci multipli e successivi che aiutano a definire più chiaramente i requisiti più importanti dato che essi verranno implementati per primi. Ogni rilascio corrisponde ad una sezione funzionante di applicazione;
	
	\item \textbf{Modello iterativo}: un modello iterativo ha la caratteristica di avere una maggior capacità di adattamento in seguito a problemi di implementazione e cambiamenti nei requisiti;
	
	\item \textbf{Organizzazione in sprint di sviluppo}: il periodo di codifica viene suddiviso in \emph{sprint} di sviluppo, data la breve durata del tirocinio curriculare essi avranno una durata di circa 4-5 giorni.
\end{itemize}
\noindent
I documenti che caratterizzano la metodologia agile utilizzata sono:
\begin{itemize}
	\item \textbf{Product backlog}: documento molto importante che contiene i requisiti e le funzionalità del prodotto definiti mediante le \emph{user stories} ordinate per priorità (\emph{business value});
	
	\item \textbf{Sprint backlog}: rappresenta l'insieme delle \emph{user stories} da realizzare nello \emph{sprint};
	
	\item \textbf{Increment}: insieme di tutte le \emph{user stories} che sono state completate dall'ultimo rilascio del software.
\end{itemize}
\noindent
La metodologia agile applicata è caratterizzata inoltre dai seguenti eventi:
\begin{itemize}
	\item \textbf{Sprint Planning}: riunione tra i partecipanti del team di sviluppo dove vengono determinati quali \emph{user stories} del \emph{product backlog} verranno completate nello \emph{sprint};
	
	\item \textbf{Daily Stand-up}: breve riunione giornaliera dove ogni membro descrive velocemente i progressi dall'ultimo \emph{Daily Stand-up}, i problemi riscontrati e i suoi prossimi obiettivi, questo evento è stato, in molte occasioni, sostituito da una riunione telematica;
	
	\item \textbf{Sprint Review}: riunione dove viene mostrato il prodotto con tutte le modifiche completate durante lo \emph{sprint} (l'insieme delle modifiche corrisponde ad un \emph{increment});
	
	\item \textbf{Backlog refinement}: riunione per aggiungere, modificare o eliminare \emph{user stories} dal \emph{product backlog};
	
	\item \textbf{Retrospective}: riunione finale dove vengono determinati i fattori positivi e negativi in modo da identificare le strategie migliori per ottenere un miglioramento continuo dei processi.
\end{itemize}
\noindent

\section{Programmazione funzionale}
La programmazione funzionale è un paradigma di programmazione dichiarativa dove un programma è costituito da una composizione di funzioni dichiarative rispetto ad una gerarchia di classi con una sequenza di operazioni imperative. In questo progetto si è cercato di applicare questo paradigma sotto due aspetti. Il primo corrisponde all'architettura dell'applicazione, infatti ho evitato di utilizzare gerarchie di classi e ho prediletto un insieme di funzioni dichiarative. \\
Il secondo invece riguarda le \gls{hofg} fornite da Kotlin; sono funzioni molto utili perchè permettono di scrivere un codice più leggibile, conciso e hanno la caratteristica di evitare \gls{sideeffectsg}. Come definito dalla documentazione di Kotlin, le funzioni scritte nel linguaggio Kotlin sono considerate come \emph{first-class} quindi esse possono essere contenute in variabili e strutture dati, passate come argomento di altre funzioni e ritornate da altre \emph{funzioni di ordine superiore}; le più usate nel progetto sono state:
\begin{itemize}
	\item \verb|map|: ritorna una nuova lista contenente i risultati ottenuti dalla funzione di trasformazione per ogni elemento della collezione originale;
	\item \verb|sortedWith|: ritorna una lista contenente tutti gli elementi della lista originale ordinati secondo un \verb|comparator| una funzione che impone una condizione tra gli elementi della lista;
	\item \verb|flatMap|: stesse funzionalità di \verb|map| ma può essere invocato su più di una lista e ritorna una collezione unica;
	\item \verb|groupBy|: raggruppa gli elementi di una lista ottenuta con i risultati della funzione \verb|keySelector| applicata ad ogni elemento della lista originale, ritorna una collezione di tipo: \verb|Map<K, V>|.
\end{itemize}

\section{Versionamento della soluzione}
\subsection{Git}
Git è un \gls{vcsg} distribuito che permette di tenere traccia delle modifiche in un prodotto software e di organizzarne la codifica. 

\subsubsection*{Feature-branch}
In questo tirocinio è stata usata la tecnica del \emph{feature-branch}: ogni aggiunta di una funzionalità corrisponde all'apertura di un nuovo \gls{branchg} che deve essere poi approvato, previa verifica, prima di essere unito al \emph{branch} \verb|master| mediante una \gls{pullreqg}.

\subsection{Gitlab}
Gitlab è uno strumento web che permette di implementare un DevOps lifecycle. In particolare fornisce un'interfaccia per gestire una repository git, un \gls{itsg} e altri strumenti quali la \gls{ci_g} e \gls{cd_g}. Per lo sviluppo di questo progetto mi è stato fornito l'accesso al server privato aziendale Gitlab.

\section{Ambiente di sviluppo locale}
\subsection{IntelliJ Idea}
IntelliJ IDEA Community Edition è una \gls{ideg} realizzata da JetBrains che fornisce funzionalità di supporto per lo sviluppo di molti linguaggi, tra cui Kotlin. Questa \emph{IDE} è stata consigliata dal mio tutor aziendale per lo sviluppo in Kotlin rispetto ad altri editor per molti vantaggi come l'autocompletamento, la possibilità di eseguire un \gls{refactoring_g} automatico di funzioni e classi e un'interfaccia grafica per eseguire task di Gradle.
 
\subsection{Gradle}
Gradle è uno strumento di \gls{buildautomationg} per molti linguaggi tra cui Kotlin e Java. Gradle è stato usato per la gestione e l'installazione delle dipendenze del componente, il file di configurazione di Gradle è \verb|build.gradle.kts|, al suo interno sono definite le seguenti dipendenze:
\begin{itemize}
	\item \verb|stdlib-js|: insieme di classi e funzioni in kotlin che forniscono un modo per utilizzare funzioni e oggetti tipici di JavaScript;
	
	\item \verb|kotlin-react|: implementazione di kotlin della liberia React;
	
	\item \verb|react|: pacchetto npm della libreria React necessario per il funzionamento di \verb|kotlin-react|;
	
	\item \verb|kotlin-redux|: implementazione di kotlin della libreria Redux;
	
	\item \verb|kotlin-react-redux|: implementazione di kotlin della libreria React, Redux;
	
	\item \verb|kotlin-extensions|: libreria che fornisce dei \gls{wrapper_g} per oggetti JavaScript e alcune funzione \emph{helper} per \verb|kotlin-react|;
	
	\item \verb|kotlinx-serialization-core|: libreria utilizzata per ottenere funzioni di parse per json;
	
	\item \verb|test-js|: libreria di test per Kotlin/Js;
	
	\item \verb|kotlinx-coroutines-core|: libreria utilizzata per eseguire funzioni asincrone.
\end{itemize}
\noindent
Oltre alla gestione delle dipendenze Gradle offre delle task, utili per compilare ed eseguire l'applicativo. Nell'ambito del progetto ho utilizzato la task: \verb|runDevelopment| e come parametro della task: \verb|--continuous| in modo da eseguire automaticamente la compilazione del codice quando viene cambiato uno dei file sorgente; questo risulta molto utile quando si codifica un'interfaccia web dato che i cambiamenti vengono visualizzati automaticamente.

\subsection{Organizzazione del lavoro}
Per l'organizzazione del lavoro, in particolare per la gestione dei macro obiettivi di ogni sprint, ho utilizzato l'\emph{ITS} fornito da Gitlab che fornisce un'interfaccia \emph{Kanban} che permette di categorizzare in modo efficace le singole attività da realizzare. \\
Per quanto riguarda le riunioni telematiche è stato usato \emph{Google meet}.
























