% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Progettazione}
\label{cap:progettazione}
%**************************************************************

%\intro{Breve introduzione al capitolo}\\
% struttura maybe?

\section{Introduzione}
In questo capitolo verrà discusso il modo in cui sono state progettate le singole parti dell'applicazione e il ragionamento alla base di tale progettazione. In particolare verranno descritte le seguenti strutture:
\begin{itemize}
	\item stato dell'applicazione;
	\item componenti grafici;
	\item parser json;
	\item adapter dello stato.
\end{itemize}

\section{Stato dell'applicazione}
\subsection{Struttura dati}
Per rappresentare la struttura dati dello stato della tabella pivot ho utilizzato le \verb|data class| di kotlin. Degli oggetti che hanno come unico scopo quello di contenere informazioni. Per prima cosa ho realizzato un nuovo package di nome \verb|Entities| all'interno dell'applicazione, al suo interno ho definito le \verb|data class|, che chiamerò con il nome di entità. \\
L'idea alla base della struttura dello stato dell'applicazione era quella di avere una struttura dati semplice da iterare in modo da avere funzioni di renderizzazione concise e facili da manutenere. Le entità che ho realizzato sono le seguenti:
\begin{itemize}
	\item \verb|TableState|;
	\item \verb|DimensionsNode|;
	\item \verb|NodeActionType|;
	\item \verb|BodyCells|;
	\item \verb|HeaderAction|.
\end{itemize}

\subsubsection{TableState}
L'entità \verb|TableState| è la \verb|data class| che contiene l'intero stato dell'applicazione. Al suo interno sono presenti tutte le informazioni necessarie per la corretta renderizzazione della tabella pivot.
\begin{lstlisting}[caption={TableState}, label={lst:tablestate}, language=Kotlin]
data class TableState(
  val cols: ArrayList<ArrayList<DimensionsNode>>,
  val rows: ArrayList<ArrayList<DimensionsNode>>,
  val cells: ArrayList<ArrayList<BodyCells>>,
  val rowAction: ArrayList<ArrayList<HeaderAction>>,
  val colAction: ArrayList<ArrayList<HeaderAction>>
)
\end{lstlisting}

\paragraph{Descrizione campi dati} \mbox{} \\
I primi due campi dati da descrivere sono \verb|cols| e \verb|rows|. Sono due matrici di \verb|NodeDimensions| che rappresentano rispettivamente le celle d'intestazione della tabella pivot delle colonne e delle righe.\\ 
%insert image
Il campo dato \verb|cells| è una matrice di \verb|BodyCells| che rappresenta le celle che contengono gli effettivi dati della tabella pivot.\\
%insert image
Infine si hanno \verb|rowAction| e \verb|colAction|. Sono due matrici di \verb|HeaderAction| e rappresentano i pulsanti all'interno del componente TableActionUI.
%insert image

\noindent

\subsubsection{DimensionsNode}
\begin{lstlisting}[caption={DimensionsNode}, label={lst:dimensionsnode}, language=Kotlin]
data class DimensionsNode(
  var id: String,
  var label: String,
  var level: Int? = null,
  var childDepth: Int? = null,
  var path: List<String>? = null,
  var actionType: NodeActionType = NodeActionType.NULL,
  var isChild: Boolean = false
)
\end{lstlisting}
\paragraph{Descrizione campi dati} \mbox{} \\

\subsubsection{HeaderAction}
\begin{lstlisting}[caption={HeaderAction}, label={lst:headeraction}, language=Kotlin]
data class HeaderAction(
  val actionType: NodeActionType,
  val dim: Int,
  val depth: Int,
)
\end{lstlisting}
\paragraph{Descrizione campi dati} \mbox{} \\


\subsubsection{NodeActionType}
\begin{lstlisting}[caption={NodeActionType}, label={lst:nodeactiontype}, language=Kotlin]
enum class NodeActionType(val type: String) {
  EXPAND("E"),
  COLLAPSE("C"),
  NULL("")
}
\end{lstlisting}
\paragraph{Descrizione campi dati} \mbox{} \\

\subsubsection{BodyCells}
\begin{lstlisting}[caption={BodyCells}, label={lst:bodycells}, language=Kotlin]
data class BodyCells(
  val value: Int,
  val cPath: List<String>,
  val rPath: List<String>
)
\end{lstlisting}
\paragraph{Descrizione campi dati} \mbox{} \\

\subsection{Stato Redux}
% maybe move to cap 1
Lo stato gestito da Redux è equivalente alla struttura di \verb|TableState| con l'aggiunta del campo dato \verb|isLoading| così da avere un variabile per gestire la tabella durante il caricamento dall'API esterna di dati. Per rendere modulare lo stato è stata realizzata una "Slice". Uno "Slice" è definito come una parte di stato dell'applicazione che può essere unito con altri slice per realizzare lo stato completo dell'applicazione. Questa architettura è molto utile per garantire scalabilità allo stato. In questo componente lo stato dell'applicazione è stato definito in uno "Slice" dello stato chiamato \verb|TableStateSlice| che è costituito da quattro elementi:
\begin{itemize}
	\item \emph{state}: \verb|data class| che contiene tutte le informazioni necessarie per la renderizzazione della tabella pivot;
	\item \emph{actions}: oggetti di tipo \verb|RAction| che vengono usati per innescare l'update dello stato; 
	\item \emph{thunk}: oggetti di tipo \verb|object| che hanno come scopo quello di realizzare operazioni complesse asincrone, è stato usato un thunk per gestire il caricamento asincrono dei dati dall'API;
	\item \emph{reducers}: funzione pura che riceve come argomento un \verb|RAction| e ritorna una copia dello stato modificato.
\end{itemize}


\section{Componenti grafici}
\subsection{View}
\subsubsection{TableView}
Questo componente è stato realizzato per definire la struttura generale del componente e per suddividere in modo responsivo lo spazio in quattro quadranti. Come si può vedere dalla seguente immagine ho realizzato il componente utilizzando il layout CSS Grid. Questo mi ha permesso di gestire, in modo responsivo, la struttura del componente.

\subsubsection{TableHeaderView}
Questo componente rappresenta le dimensioni superiori della tabella pivot.
Dire che la struttura della tabella è stata realizzata con flex, table, etc.

\subsubsection{TableSidebarView}
Questo componente rappresenta le dimensioni laterali della tabella pivot.
Dire che la struttura della tabella è stata realizzata con flex, table, etc.

\subsubsection{TableBodyView}
Questo componente rappresenta i dati della tabella pivot
Dire che la struttura della tabella è stata realizzata con flex, table, etc.

\subsubsection{TableLabel}
Questo componente rappresenta i dati della tabella pivot
Dire che la struttura della tabella è stata realizzata con flex, table, etc.

\subsubsection{TableActionUI}
Questo componente rappresenta i dati della tabella pivot
Dire che la struttura della tabella è stata realizzata con flex, table, etc.

\subsection{Container Redux}
\subsubsection{TableController}
\subsubsection{TableHeaderController}
\subsubsection{TableSidebarController}
\subsubsection{TableBodyController}
\subsubsection{TableActionUIController}
\subsubsection{TableLabelController}

\section{Parser JSON}
\subsection{Struttura dati @Serializable}

\section{Adapter}
\subsection{Utilizzo del paradigma della programmazione funzionale}
\subsubsection{Funzioni utilizzate}


%**************************************************************
%\section{Introduzione al progetto}

%**************************************************************
%\section{Analisi preventiva dei rischi}

%Durante la fase di analisi iniziale sono stati individuati alcuni possibili rischi a cui si potrà andare incontro.
%Si è quindi proceduto a elaborare delle possibili soluzioni per far fronte a tali rischi.\\

%\begin{risk}{Performance del simulatore hardware}
%    \riskdescription{le performance del simulatore hardware e la comunicazione con questo potrebbero risultare lenti o non abbastanza buoni da causare il fallimento dei test}
%    \risksolution{coinvolgimento del responsabile a capo del progetto relativo il simulatore hardware}
 %   \label{risk:hardware-simulator} 
%\end{risk}

%**************************************************************
%\section{Requisiti e obiettivi}


%**************************************************************
%\section{Pianificazione}