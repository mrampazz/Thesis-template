% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Progettazione}
\label{cap:progettazione}
%**************************************************************

In questo capitolo verrà descritta la progettazione dell'intero prodotto. In particolare verranno spiegati i seguenti argomenti:
\begin{itemize}
	\item Dataflow dell'applicazione;
	\item Gestione dello stato;
	\item Stato;
	\item Parser e adapter;
	\item Componenti grafici.
\end{itemize}

\section{Dataflow dell'applicazione}
Un aspetto che è stato molto discusso dal team di sviluppo riguarda il \emph{dataflow}\glosp dell'applicazione. Durante la prima settimana del tirocinio, oltre allo studio delle tecnologie, si è pensato a come verrà gestito lo stato dell'applicazione e in particolare delle possibili soluzioni per garantirne la scalabilità. In questa sezione verrà descritto il dataflow fornito da React e Redux, infine verrà identificato il dataflow adottato nell'ambito del progetto.

\subsection{React}
React è una libreria per realizzare interfacce utente che utilizza un \emph{dataflow} unidirezionale. Questo perchè ogni componente può avere uno stato locale accessibile solo da se stesso e può passare informazioni ai suoi componenti figli mediante le \emph{props}\glo. Il risultato è uno stato che dipende dalla gerarchia di componenti grafici. \\
Questo dataflow è molto semplice però presenta alcune limitazioni per quanto riguarda la scalabilità. Per avere uno stato unico di tutta l'applicazione bisognerebbe dare la responsabilità ad un componente grafico di gestirlo e passarlo mediante le sue \emph{props}. L'architettura che ne deriva, nel caso di applicazioni complesse con molti componenti, è limitata, difficile da manutenere e poco scalabile. \\
Tuttavia questo semplice dataflow ha il vantaggio che per famiglie di componenti piccole i cambiamenti di stato locale e i passaggi di informazioni mediante le \emph{props} sono molto veloci e semplici.

\subsection{Redux}
Per garantire scalabilità e facilità nella gestione dello stato dell'applicazione abbiamo discusso riguardo l'utilizzo di Redux. Essa offre un dataflow unidirezionale dove lo stato è gestito in una struttura di Redux chiamata \emph{store}. Questa struttura esterna ai componenti grafici rende la gestione dello stato dell'applicazione più prevedibile e manutenibile. Redux si basa su tre principi:
\begin{itemize}
	\item lo stato è l'unica fonte di verità;
	\item lo stato non è modificabile direttamente;
	\item le modifiche avvengono medianti \emph{funzioni pure}\glosp che creano un nuovo stato per evitare \emph{side effects}\glo.
\end{itemize}
\noindent
Gli elementi dell'architettura di Redux sono i seguenti:
\begin{itemize}
	\item \textbf{Actions}: oggetti che rappresentano un azione che innesca un update dello stato;
	\item \textbf{Reducers}: \emph{funzioni pure} che hanno come parametro un Actions e si occupano di modificare lo stato;
	\item \textbf{Store}: lo Store è un'interfaccia che contiene lo stato dell'applicazione e fornisce funzioni per leggere, modificare e registrare \emph{listeners}\glosp allo stato.
\end{itemize}
\noindent

\subsection{Soluzione}
La soluzione adottata è stata quella di usare sia React che Redux. React è stato usato per gestire solo gli aggiornamenti visivi dell'applicazione, mentre Redux per gestire lo stato completo dell'applicazione. Il dataflow del prodotto è quindi il seguente:
\begin{enumerate}
	\item se l'utente esegue una azione che implica un cambiamento dello stato verrà mandata allo Store una Action;
	\item lo Store si occuperà di chiamare un Reducer in modo da ricevere lo stato successivo;
	\item lo stato verrà aggiornato e i cambiamenti saranno visibili a tutti i componenti React che sono registrati allo Store.
\end{enumerate}
Utilizzando questo dataflow lo stato dell'applicazione non dipende da un componente grafico perchè è esterno alla gerarchia dei componenti grafici. Quindi ogni componente React che ha bisogno di una frazione dei dati dello stato può semplicemente registrarsi allo Store per ricevere i dati.

\section{Gestione dello stato}
Come descritto nella sezione precedente nell'ambito di questo progetto è stata adottata la libreria Redux, per applicare al meglio la sua architettura ho progettato la sua codifica nel seguente modo. Per prima cosa ho suddiviso lo stato dell'applicazione in "Slice" cioè in pezzo di stato. In questo modo la struttura dello stato è modulare e scalabile dato che, se questa applicazione verrà ampliata in un futuro basterà aggiungere uno slice allo stato. Ogni slice deve essere strutturato nel seguente modo:
\begin{lstlisting}[caption={Esempio Slice}, label={lst:bodycells}, language=Kotlin]
object Slice {
	// Stato
	data class State( ... )
	
	// Thunk
	private val thunk = Thunk()
	fun funcThunk() : RThunk = thunk
	
	// Actions
	class Action(): RAction
	...
	
	// Reducer
	fun reducer(state: State = State(), action: RAction) : State { ... }
}
\end{lstlisting}

\subsection{Stato}
Lo stato gestito da Redux è definito da un data class che contiene tutte le informazioni dello Slice.

\subsection{Thunk}
Dato che i cambiamenti allo stato innescati dalle Actions possono essere solo sincroni ho utilizzato un interfaccia che fornisce le stesse funzionalità di un Actions ma ne espande l'utilità permettendo operazioni asincrone, questa interfaccia è definita come \verb|thunk|.
I \emph{thunk} sono definiti come \emph{middleware} di Redux e sono usati per effettuare operazioni asincrone complesse, l'interfaccia dei Thunk purtroppo non era presente nell'implementazione di Redux di kotlin quindi ho realizzato una semplice interfaccia che implementa le funzionalità dei thunk.

\begin{lstlisting}[caption={Interfaccia Thunk}, label={lst:bodycells}, language=Kotlin]
interface RThunk : RAction {
	operator fun invoke(
	dispatch: (RAction) -> WrapperAction,
	getState: () -> AppState
	) : WrapperAction
}

fun rThunk() =
applyMiddleware<AppState, RAction, WrapperAction, RAction, WrapperAction>(
{ store ->
	{ next ->
		{ action ->
			if (action is RThunk)
			  action(store::dispatch, store::getState)
			else
			  next(action)
		}
	}
}
)

val nullAction = js {}.unsafeCast<WrapperAction>()
\end{lstlisting}
\subsection{Actions}
Le actions sono definiti come delle classi di tipo \verb|RAction| che vengono usati per innescare l'update dello stato.

\subsection{Reducer}
Un \emph{reducer} è una \emph{funzione pura} che riceve come argomento un \verb|RAction| e ritorna una copia dello stato modificato. 

\section{Stato}
Per quanto riguarda lo stato dell'applicazione ho analizzato la struttura della tabella fornita dall'azienda e le funzionalità richieste. L'idea alla base della struttura dello stato era quella di avere una struttura dati semplice da iterare in modo da avere funzioni di renderizzazione concise e facili da manutenere. Dalla struttura della tabella pivot e dalla descrizione delle sue funzionalità ho ricavato le seguenti strutture dati:
\paragraph*{data class DimensionsNode}- rappresenta una cella d'intestazione, deve contenere:
\begin{itemize}
	\item \verb|id|: codice della cella;
	\item \verb|label|: testo da renderizzare;
	\item \verb|level|: indica a che dimensione dell'intestazione appartiene la cella;
	\item \verb|childDepth|: indica la profondità della cella in una gerarchia ad albero;
	\item \verb|path|: codice identificativo della cella costituito da una lista di \verb|id| che rappresenta la gerarchia di una cella;
	\item \verb|actionType|: indica il tipo dell'azione che bisogna eseguire, esso verrà indicato con una classe di tipo: \verb|enum class NodeActionType|;
	\item \verb|isChild|: indica se la cella è un figlio di un'altra cella.
\end{itemize}
	
\paragraph*{data class BodyCells}- rappresenta una cella dei dati, deve contenere:
\begin{itemize}
	\item \verb|value|: indica il dato;
	\item \verb|cPath|: indica l'insieme dei codici delle dimensioni delle colonne a cui appartiene il dato;
	\item \verb|rPath|: indica l'insieme dei codici delle dimensioni delle righe a cui appartiene il dato.
\end{itemize}	

\paragraph*{data class HeaderAction}- rappresenta un tipo di azione, deve contenere:
\begin{itemize}
	\item \verb|actionType|:  indica il tipo dell'azione che bisogna eseguire, esso verrà indicato con una classe di tipo: \verb|enum class NodeActionType|;
	\item \verb|dim|: indica la dimensione su cui applicare l'azione;
	\item \verb|depth|: indica la profondità all'interno della dimensione su cui applicare l'azione.
\end{itemize}

\paragraph*{enum class NodeActionType}- rappresenta un tipo di azione:
\begin{itemize}
	\item \verb|EXPAND|:  indica che la cella può espandere per mostrare i suoi figli;
	\item \verb|COLLAPSE|: indica che la cella può nascondere i suoi figli;
	\item \verb|NULL|: indica che la cella non ha un'azione.
\end{itemize}

\section{Parser e adapter}
Per la progettazione ho per prima cosa definito i passaggi necessari per ricevere i dati dalla API di Gruppo4. Ho individuato la necessità di due funzioni \verb|fetch| e \verb|sendAction|, la prima per richiedere i dati iniziali e la seconda per ottenere nuovi dati in seguito all'azione passata per argomento a \verb|sendAction|. \\
Per quanto riguarda il parser del json ho studiato la struttura del json ritornato dall'API in modo da identificare tutte le data class \verb|@Serializable| che mi permetteranno di mappare il json in data class. La struttura del json è la seguente:
\begin{lstlisting}[caption={Struttura JSON API}, label={lst:bodycells}, language=json]
{
	"Rows": {
		"Paths": [
		["_all", "_all", ...], [ ... ]
		],
		"Actions": [
		{ "Action": "C", "Dim": 1, "Depth": 0 }, { ... }
		],
		"Tree": [
		{
			"Code": "_all",
			"Label": "All",
			"SubDim": [
			{
				"Code": "_all",
				"Label": "All",
				"SubDim": null,
				"Children": null
			}
			]  
		}
		]
	}
	"Cols": // stessa struttura di "Rows"
	"Cells": [
	[51515, 2315, 747, 22],
	[ ... ]
	]
}
\end{lstlisting}
Da questa struttura ho identificato le seguenti \verb|data class @Serializable|:
\begin{itemize}
	\item \verb||;
	\item \verb||;
	\item \verb||;
	\item \verb||;
	\item \verb||;
\end{itemize}

Per quanto riguarda la progettazione dell'adapter ho individuato le data class ottenibili dal JSON e le data class definite nello stato. Da esse ho individuato le seguenti funzioni:
\begin{itemize}
	\item \verb||;
	\item \verb||;
	\item \verb||;
	\item \verb||;
	\item \verb||;
\end{itemize}

\section{Componenti grafici}
Per quanto riguarda la struttura dei componenti grafici l'azienda mi ha dato completa libertà per quanto riguarda la loro struttura. La progettazione di essi consiste nel loro mockup e la definizione degli stili grafici necessari. Questa prima immagine rappresenta il mockup iniziale da cui sono partito:
% mockup generale
Da questo mockup general ho individuato i seguenti componenti:
\begin{itemize}
	\item \verb||;
	\item \verb||;
	\item \verb||;
	\item \verb||;
	\item \verb||;
\end{itemize}

Di seguito sono dei mockup di tutti i componenti che ho individuato nella tabella pivot:
% altri mockup












%**************************************************************
%\section{Introduzione al progetto}

%**************************************************************
%\section{Analisi preventiva dei rischi}

%Durante la fase di analisi iniziale sono stati individuati alcuni possibili rischi a cui si potrà andare incontro.
%Si è quindi proceduto a elaborare delle possibili soluzioni per far fronte a tali rischi.\\

%\begin{risk}{Performance del simulatore hardware}
%    \riskdescription{le performance del simulatore hardware e la comunicazione con questo potrebbero risultare lenti o non abbastanza buoni da causare il fallimento dei test}
%    \risksolution{coinvolgimento del responsabile a capo del progetto relativo il simulatore hardware}
 %   \label{risk:hardware-simulator} 
%\end{risk}

%**************************************************************
%\section{Requisiti e obiettivi}


%**************************************************************
%\section{Pianificazione}