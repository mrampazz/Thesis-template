% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Progettazione}
\label{cap:progettazione}
%**************************************************************

%\intro{Breve introduzione al capitolo}\\
% struttura maybe?

\section{Introduzione}
In questo capitolo verrà discusso il modo in cui sono state progettate le singole parti dell'applicazioni e il ragionamento alla base di tale progettazione. In particolare verranno descritte le seguenti strutture:
\begin{itemize}
	\item stato dell'applicazione;
	\item componenti grafici;
	\item parser json;
	\item adapter dello stato.
\end{itemize}

\section{Stato dell'applicazione}
\subsection{Struttura dati}
Per rappresentare la struttura dati dello stato della tabella pivot ho utilizzato le 'data class' di kotlin. Degli oggetti, molto simili ad oggetti JavaScript che hanno come unico scopo quello di contenere informazioni. La struttura dati dell'applicazione è descritta mediante 'data class TableState' descritta nel seguente modo:
\begin{lstlisting}[caption={TableState}, label={lst:example1}, language=Kotlin]
data class TableState(
  val cols: ArrayList<ArrayList<DimensionsNode>>,
  val rows: ArrayList<ArrayList<DimensionsNode>>,
  val cells: ArrayList<ArrayList<BodyCells>>,
  val rowAction: ArrayList<ArrayList<HeaderAction>>,
  val colAction: ArrayList<ArrayList<HeaderAction>>
)
\end{lstlisting}
\noindent
\\
Le altre dataclass utilizzate dallo stato dell'applicazione sono: DimensionsNode, NodeActionType, HeaderAction e BodyCells.
\begin{lstlisting}[caption={DimensionsNode}, label={lst:example1}, language=Kotlin]
data class DimensionsNode(
  var id: String,
  var label: String,
  var level: Int? = null,
  var childDepth: Int? = null,
  var path: List<String>? = null,
  var actionType: NodeActionType = NodeActionType.NULL,
  var isChild: Boolean = false
)
\end{lstlisting}

\begin{lstlisting}[caption={BodyCells}, label={lst:example1}, language=Kotlin]
data class HeaderAction(
  val actionType: NodeActionType,
  val dim: Int,
  val depth: Int,
)

enum class NodeActionType(val type: String) {
  EXPAND("E"),
  COLLAPSE("C"),
  NULL("")
}
\end{lstlisting}

\begin{lstlisting}[caption={BodyCells}, label={lst:example1}, language=Kotlin]
data class BodyCells(
  val value: Int,
  val cPath: Array<String>,
  val rPath: Array<String>
)
\end{lstlisting}

\subsection{Stato Redux}

\section{Componenti grafici}
\subsection{View}
\subsection{Container}

\section{Parser JSON}
\subsection{Struttura dati @Serializable}

\section{Adapter}
\subsection{Utilizzo del paradigma della programmazione funzionale}
\subsubsection{Funzioni utilizzate}

\section{Suddivisione dei componenti grafici}
\subsection{View}
\subsubsection{TableView}
Questo componente è stato realizzato per definire la struttura generale del componente e per suddividere in modo responsivo lo spazio in quattro quadranti. Come si può vedere dalla seguente immagine ho realizzato il componente utilizzando il layout CSS Grid. Questo mi ha permesso di gestire, in modo responsivo, la struttura del componente.

\subsubsection{TableHeaderView}
Questo componente rappresenta le dimensioni superiori della tabella pivot.
Dire che la struttura della tabella è stata realizzata con flex, table, etc.

\subsubsection{TableSidebarView}
Questo componente rappresenta le dimensioni laterali della tabella pivot.
Dire che la struttura della tabella è stata realizzata con flex, table, etc.

\subsubsection{TableBodyView}
Questo componente rappresenta i dati della tabella pivot
Dire che la struttura della tabella è stata realizzata con flex, table, etc.

\subsubsection{TableLabel}
Questo componente rappresenta i dati della tabella pivot
Dire che la struttura della tabella è stata realizzata con flex, table, etc.

\subsubsection{TableActionUI}
Questo componente rappresenta i dati della tabella pivot
Dire che la struttura della tabella è stata realizzata con flex, table, etc.


\subsection{Container Redux}
\subsubsection{TableController}
\subsubsection{TableHeaderController}
\subsubsection{TableSidebarController}
\subsubsection{TableBodyController}
\subsubsection{TableActionUIController}
\subsubsection{TableLabelController}


\section{Struttura dati dell'applicazione}
\subsection{Descrizione}
Per definire lo stato dell'applicazione sono state create delle 'data class' per gestire in modo ordinato lo stato del prodotto.
\subsubsection{TableState}
Lo stato del prodotto è definito da un singolo oggetto: 'data class TableState'.
\subsubsection{Cells}
\subsubsection{CellAction}
\subsubsection{BodyCells}


\section{Realizzazione del JSON parser}
Lo stato dell'applicazione viene popolato in seguito ad una richiesta ad API. Queste API ritornano risultati in formato JSON. Lavorando con Kotlin non è possibile avere la stessa libertà di accesso ad un JSON come in Javascript, quindi sono stati creati delle classi per eseguire la lettura del JSON e la sua traduzione in oggetti 'data class'. GRUPPO4 ha fornito una API che deve essere compatibili con questo componente quindi per ho realizzato un parser per trasformare un json in oggetti 'data class' e un adapter per trasformare gli oggetti data class nella data structure utilizzata nello stato dell'applicazione.

\subsection{Adapter: creavista}
Descrivi l'API\\
Descrivi il parser\\
La realizzazione del parse e del successivo adapter è stato uno delle difficoltà più grandi che ho superato. La struttura del JSON faceva cagare. Per realizzare un datastructure decente ho preso i dati dal json e li ho trasformati in una rappresentazione ad albero. Nel seguente modo:
ESEMPIO FOTO OR WHATEVER.
Dopodichè ho trasformato la rappresentazione ad albero degli oggetti in List che costituite nel seguente modo: ESEMPIO. IN particolare per quanto riguarda la dimensione delle righe ho suddiviso questa list in tante liste quante sono le dimensioni delle righe. Mentre per le coonne ho suddiviso la List in tante liste quante sono le dimensioni delle colonne.

Descrivi le funzioni\\


%**************************************************************
%\section{Introduzione al progetto}

%**************************************************************
%\section{Analisi preventiva dei rischi}

%Durante la fase di analisi iniziale sono stati individuati alcuni possibili rischi a cui si potrà andare incontro.
%Si è quindi proceduto a elaborare delle possibili soluzioni per far fronte a tali rischi.\\

%\begin{risk}{Performance del simulatore hardware}
%    \riskdescription{le performance del simulatore hardware e la comunicazione con questo potrebbero risultare lenti o non abbastanza buoni da causare il fallimento dei test}
%    \risksolution{coinvolgimento del responsabile a capo del progetto relativo il simulatore hardware}
 %   \label{risk:hardware-simulator} 
%\end{risk}

%**************************************************************
%\section{Requisiti e obiettivi}


%**************************************************************
%\section{Pianificazione}